// Generated by CoffeeScript 1.10.0

/*
	Organism

	An organism object contains sets of nodes and factors. It has a stress 
	mode, which is used to determine ways of calculating its disharmony.
	The threshold for when to enter or leave stress mode is self-adjusting 
	over time, meaning it will normalize to the current disharmony state 
	every once in a while.

	It also provides methods for getting historical disharmony data regarding
	its nodes and factors.

	@author Alexander Wallin
	@url    http://alexanderwallin.com
 */

(function() {
  var Organism;

  Organism = (function() {
    Organism.NUM_FACTORS = 5;

    Organism.DEFAULT_NUM_NODES = 10;

    Organism.DISTRIBUTE_FACTOR_VALUES = false;

    Organism.STRESS_THRESHOLD_ENTER = 1;

    Organism.STRESS_THRESHOLD_LEAVE = 2;

    function Organism(numNodes) {
      var i;
      if (numNodes == null) {
        numNodes = -1;
      }
      this._sumDisharmony = 0;
      this._actualDisharmony = 0;
      this._inStressMode = false;
      this.stress = {
        thresholdEnter: 0,
        thresholdLeave: 0
      };
      EventDispatcher.trigger('audanism/organism/stressmode', this._inStressMode);
      this._stressAdjustmentTime = 8000;
      this._stressAdjustmentInterval = setInterval(this.adjustStressThresholds.bind(this), this._stressAdjustmentTime);
      this._factors = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 1, ref = Audanism.Environment.Organism.NUM_FACTORS; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
          results.push(Audanism.Factor.Factor.createFactor(i, 0));
        }
        return results;
      })();
      EventDispatcher.trigger('audanism/init/factors', [this._factors]);
      if (numNodes <= 0) {
        numNodes = Audanism.Environment.Organism.DEFAULT_NUM_NODES;
      }
      this._createNodes(numNodes);
      EventDispatcher.trigger('audanism/init/nodes', [this._nodes]);
      EventDispatcher.listen('audanism/node/add', this, (function(_this) {
        return function(info) {
          return _this._createNodes(info.numNodes);
        };
      })(this));
      this.disharmonyCalculator = new Audanism.Calculator.DisharmonyCalculator(this);
      this.disharmonyHistory = [];
    }

    Organism.prototype.getNode = function(nodeId) {
      if (this._nodes[nodeId] != null) {
        return this._nodes[nodeId];
      } else {
        return null;
      }
    };

    Organism.prototype.getNodesWithCellsOfFactorType = function(factorType) {
      return this._nodeCellIndex[factorType];
    };

    Organism.prototype.getNodes = function() {
      return this._nodes;
    };

    Organism.prototype.getFactors = function() {
      return this._factors;
    };

    Organism.prototype.getFactorOfType = function(factorType) {
      var factor, foundFactor, j, len, ref;
      foundFactor = null;
      ref = this._factors;
      for (j = 0, len = ref.length; j < len; j++) {
        factor = ref[j];
        if (factor.factorType === factorType) {
          foundFactor = factor;
        }
      }
      return foundFactor;
    };

    Organism.prototype.performNodeComparison = function(numComparisons) {
      var comparisonMode, factor, i, j, k, len, nodes, ref, ref1;
      if (numComparisons == null) {
        numComparisons = 1;
      }
      this.isInitialComparison = this._sumDisharmony === 0;
      this.disharmonyCalculator.debug = true;
      for (i = j = 1, ref = numComparisons; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        nodes = this._getRandomNodes(2);
        comparisonMode = this._inStressMode && false ? Audanism.Calculator.DisharmonyCalculator.NODE_COMPARISON_MODE_FACTOR_HARMONY : Audanism.Calculator.DisharmonyCalculator.NODE_COMPARISON_MODE_ORGANISM_HARMONY;
        EventDispatcher.trigger('audanism/compare/nodes', [
          {
            'nodes': nodes,
            'comparisonMode': comparisonMode
          }
        ]);
        this.disharmonyCalculator.alterNodesInComparisonMode(nodes, comparisonMode);
      }
      this.disharmonyCalculator.debug = false;
      this._sumDisharmony = this.disharmonyCalculator.getSummedOrganismDisharmony(this);
      this._actualDisharmony = this.disharmonyCalculator.getActualOrganismDisharmony(this);
      this.disharmonyHistory.push([this.disharmonyHistory.length, this._sumDisharmony, this._actualDisharmony]);
      ref1 = this._factors;
      for (k = 0, len = ref1.length; k < len; k++) {
        factor = ref1[k];
        factor.setDisharmony(this.disharmonyCalculator.getFactorDisharmonyForNodes(factor, this._nodes));
      }
      if (this.isInitialComparison) {
        this.stress.thresholdEnter = this._actualDisharmony * 1.2;
      }
      if (!this._inStressMode && this._actualDisharmony > this.stress.thresholdEnter) {
        this._inStressMode = true;
        this.stress.thresholdLeave = this.stress.thresholdEnter * 1;
        EventDispatcher.trigger('audanism/organism/stressmode', this._inStressMode);
        clearInterval(this._stressAdjustmentInterval);
        return this._stressAdjustmentInterval = setInterval(this.adjustStressThresholds.bind(this), this._stressAdjustmentTime);
      } else if (this._inStressMode && this._actualDisharmony < this.stress.thresholdLeave) {
        this._inStressMode = false;
        this.stress.thresholdEnter = this.stress.thresholdLeave * 1.2;
        EventDispatcher.trigger('audanism/organism/stressmode', this._inStressMode);
        clearInterval(this._stressAdjustmentInterval);
        return this._stressAdjustmentInterval = setInterval(this.adjustStressThresholds.bind(this), this._stressAdjustmentTime);
      }
    };

    Organism.prototype.getDisharmonyHistoryData = function(numEntries) {
      if (numEntries == null) {
        numEntries = 300;
      }
      if (numEntries > 0) {
        return this.disharmonyHistory.slice(-numEntries);
      } else {
        return this.disharmonyHistory.slice(-this.disharmonyHistory.length);
      }
    };

    Organism.prototype.getAverageDisharmony = function(numEntries, type) {
      var entry, history, j, len, sum;
      if (type == null) {
        type = 'sum';
      }
      history = this.getDisharmonyHistoryData(numEntries);
      sum = 0;
      for (j = 0, len = history.length; j < len; j++) {
        entry = history[j];
        sum += (type === 'actual' ? entry[2] : entry[1]);
      }
      return sum / history.length;
    };

    Organism.prototype.getDisharmonyChange = function(entriesBack, type) {
      var dataIndex, history;
      if (entriesBack == null) {
        entriesBack = 2;
      }
      if (type == null) {
        type = 'sum';
      }
      history = this.getDisharmonyHistoryData(entriesBack);
      dataIndex = type === 'actual' ? 2 : 1;
      return history[history.length - 1][dataIndex] / history[0][dataIndex];
    };

    Organism.prototype.getDisharmonyChangeForFactor = function(factorType, entriesBack) {
      var factor, history;
      if (entriesBack == null) {
        entriesBack = 2;
      }
      factor = this.getFactorOfType(factorType);
      history = factor.disharmonyHistory.slice(entriesBack < factor.disharmonyHistory.length ? -entriesBack : 0);
      return history[history.length - 1] / history[0];
    };

    Organism.prototype.adjustStressThresholds = function() {
      if (this._inStressMode) {
        return this.stress.thresholdLeave = this._actualDisharmony * 1;
      } else {
        return this.stress.thresholdEnter = this._actualDisharmony * 1.2;
      }
    };

    Organism.prototype._createNodes = function(numNodes) {
      var cell, factor, i, j, k, l, len, len1, len2, len3, len4, len5, m, n, node, nodes, nodesWithFactorCells, o, ref, ref1, ref2, results, results1;
      if (!this._nodeCellIndex) {
        this._nodeCellIndex = [];
        ref = this._factors;
        for (j = 0, len = ref.length; j < len; j++) {
          factor = ref[j];
          this._nodeCellIndex[factor.factorType] = [];
        }
      }
      if (!this._nodes) {
        this._nodes = [];
      }
      nodes = (function() {
        var k, ref1, results;
        results = [];
        for (i = k = 1, ref1 = numNodes; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
          results.push(new Audanism.Node.Node());
        }
        return results;
      })();
      for (k = 0, len1 = nodes.length; k < len1; k++) {
        node = nodes[k];
        this._nodes[node.nodeId] = node;
      }
      for (l = 0, len2 = nodes.length; l < len2; l++) {
        node = nodes[l];
        ref1 = node.getCells();
        for (m = 0, len3 = ref1.length; m < len3; m++) {
          cell = ref1[m];
          this._nodeCellIndex[cell.factorType].push(node);
        }
      }
      if (Organism.DISTRIBUTE_FACTOR_VALUES) {
        ref2 = this._factors;
        results = [];
        for (n = 0, len4 = ref2.length; n < len4; n++) {
          factor = ref2[n];
          nodesWithFactorCells = this.getNodesWithCellsOfFactorType(factor.factorType);
          results.push((function() {
            var o, ref3, results1;
            results1 = [];
            for (i = o = 1, ref3 = factor.factorValue; 1 <= ref3 ? o <= ref3 : o >= ref3; i = 1 <= ref3 ? ++o : --o) {
              results1.push(getRandomElements(nodesWithFactorCells, 1)[0].addCellValue(factor.factorType, 1));
            }
            return results1;
          })());
        }
        return results;
      } else {
        results1 = [];
        for (o = 0, len5 = nodes.length; o < len5; o++) {
          node = nodes[o];
          results1.push((function() {
            var len6, p, ref3, results2;
            ref3 = node.getCells();
            results2 = [];
            for (p = 0, len6 = ref3.length; p < len6; p++) {
              cell = ref3[p];
              results2.push(cell.factorValue = Math.randomRange(0, 100));
            }
            return results2;
          })());
        }
        return results1;
      }
    };

    Organism.prototype._getRandomNodes = function(numNodes) {
      var allNodeIndexes, i, j, k, len, nodeIndexes, ref, results, results1;
      allNodeIndexes = (function() {
        results = [];
        for (var j = 0, ref = this._nodes.length - 1; 0 <= ref ? j <= ref : j >= ref; 0 <= ref ? j++ : j--){ results.push(j); }
        return results;
      }).apply(this);
      nodeIndexes = (function() {
        var k, ref1, results1;
        results1 = [];
        for (i = k = 1, ref1 = numNodes; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
          results1.push(allNodeIndexes.splice(Math.floor(Math.random() * allNodeIndexes.length), 1));
        }
        return results1;
      })();
      results1 = [];
      for (k = 0, len = nodeIndexes.length; k < len; k++) {
        i = nodeIndexes[k];
        results1.push(this._nodes[i]);
      }
      return results1;
    };

    Organism.prototype._getRandomNodesOfFactorType = function(factorType, numNodes) {
      return getRandomElements(this._nodeCellIndex[factorType], numNodes);
    };

    return Organism;

  })();

  window.Audanism.Environment.Organism = Organism;

}).call(this);
