// Generated by CoffeeScript 1.4.0

/*
	Voice

	Voice is a super-class for synthesizers. It is only alive during its 
	note's duration.

	It has one dry channel and one wet, containing FXChains. FXChains
	can be added dynamically.
*/


(function() {
  var Voice;

  Voice = (function() {

    function Voice(note, fxIn, masterWet) {
      this.note = note;
      this.fxIn = fxIn;
      this.masterWet = masterWet;
      this.oscillators = [];
      this.envelopes = [];
      this.waitTime = 0;
      /*
      		Note: Effects on voices are currently forbidden. Only the master
      		end chain will have reverbs and stuff.
      
      		Effects stuff are commented out.
      */

      this.pan = Audanism.Audio.audioContext.createPanner();
      this.masterVol = Audanism.Audio.audioContext.createGain();
      this.masterVol.gain.value = 0.0005;
      /*
      		Connect stuff together
      */

      this.pan.connect(this.masterVol);
    }

    Voice.prototype.noteOn = function(length) {
      var attackEndTime, decayEndTime, env, extraLength, i, now, releaseEndTime, releaseStartTime, _i, _ref, _results;
      extraLength = length > this.asdr.attack + this.asdr.decay ? length - this.asdr.attack - this.asdr.decay : 0;
      now = Audanism.Audio.audioContext.currentTime + this.waitTime;
      attackEndTime = now + this.asdr.attack;
      decayEndTime = attackEndTime + this.asdr.decay;
      releaseStartTime = length >= 0 ? decayEndTime + extraLength : 0;
      releaseEndTime = releaseStartTime + this.asdr.release;
      _results = [];
      for (i = _i = 0, _ref = this.envelopes.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        env = this.envelopes[i];
        env.gain.cancelScheduledValues(now);
        env.gain.setValueAtTime(env.gain.value, now);
        env.gain.linearRampToValueAtTime(1, attackEndTime);
        env.gain.linearRampToValueAtTime(this.asdr.sustain, decayEndTime);
        if (extraLength > 0) {
          env.gain.linearRampToValueAtTime(this.asdr.sustain, releaseStartTime);
        }
        if (length >= 0) {
          _results.push(env.gain.linearRampToValueAtTime(0, releaseEndTime));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Voice.prototype.noteOff = function() {
      var env, i, now, releaseEndTime, _i, _ref, _results;
      now = Audanism.Audio.audioContext.currentTime;
      releaseEndTime = now + this.asdr.release;
      _results = [];
      for (i = _i = 0, _ref = this.envelopes.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        env = this.envelopes[i];
        env.gain.cancelScheduledValues(now);
        env.gain.setValueAtTime(env.gain.value, now);
        env.gain.linearRampToValueAtTime(0, releaseEndTime);
        try {
          _results.push(this.oscillators[i].stop(releaseEndTime + 0.01));
        } catch (e) {

        }
      }
      return _results;
    };

    Voice.prototype.stop = function(wait) {
      var osc, _i, _len, _ref, _results;
      if (wait == null) {
        wait = 0;
      }
      _ref = this.oscillators;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        osc = _ref[_i];
        _results.push(osc.stop(wait));
      }
      return _results;
    };

    /*
    	# Creates and returns an fx chain
    	createFxChain: () ->
    
    		id = @fxChains.length
    		console.log('Voice#createFxChain()')
    		console.log('...id', id)
    
    		chain = new Audanism.Audio.FX.FXChain( @fxIn, @masterWet )
    
    		#@fxIn.connect( chain.in )
    		#chain.out.connect( @masterWet )
    
    		@fxChains[@fxChains.length] = chain
    		return chain
    
    
    	# Adds an effect to the main signal chain
    	# @masterWet -> @fx -> @panPostFx
    	addFx: (@fx) ->
    		id = @fxs.length
    
    		if id is 0
    			@masterWet.disconnect( 0 )
    			@masterWet.connect( @fx.in )
    		else
    			@fxs[id - 1].out.disconnect( 0 )
    			@fxs[id - 1].out.connect( @fx.in )
    		
    		@fx.out.connect( @panPostFx )
    		@fxs[id] = @fx
    
    	# Pan pre fx
    	setPanPreFx: (pan) ->
    		@panPreFx.setPosition( pan, 0, 0 )
    
    
    	# Pan post fx
    	setPanPostFx: (pan) ->
    		@panPostFx.setPosition( pan, 0, 0 )
    
    
    	# Dry amount
    	setDryAmunt: (dryAmount) ->
    		@dry.gain.value = dryAmount
    
    
    	# Wet (fx) amount
    	setMasterWetAmount: (wetAmount) ->
    		@masterWet.gain.value = wetAmount
    */


    Voice.prototype.setPan = function(pan) {
      return this.pan.setPosition(pan, 0, 0);
    };

    Voice.prototype.getRandomOscType = function() {
      var oscTypes;
      oscTypes = ['sine', 'sawtooth', 'square', 'triangle'];
      return oscTypes[randomInt(0, 3)];
    };

    return Voice;

  })();

  window.Audanism.Audio.Synthesizer.Voice = Voice;

}).call(this);
