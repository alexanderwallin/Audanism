// Generated by CoffeeScript 1.10.0

/*
	Voice

	Voice is a super-class for synthesizers. It is only alive during its 
	note's duration.

	It has one dry channel and one wet, containing FXChains. FXChains
	can be added dynamically.
 */

(function() {
  var Voice;

  Voice = (function() {
    function Voice(note, fxIn, masterWet) {
      this.note = note;
      this.fxIn = fxIn;
      this.masterWet = masterWet;
      this.oscillators = [];
      this.envelopes = [];
      this.waitTime = 0;

      /*
      		Note: Effects on voices are currently forbidden. Only the master
      		end chain will have reverbs and stuff.
      
      		Effects stuff are commented out.
       */
      this.pan = Audanism.Audio.audioContext.createPanner();
      this.masterVol = Audanism.Audio.audioContext.createGain();
      this.masterVol.gain.value = 0.0005;

      /*
      		Connect stuff together
       */
      this.pan.connect(this.masterVol);
    }

    Voice.prototype.noteOn = function(length) {
      var attackEndTime, decayEndTime, env, extraLength, i, j, now, ref, releaseEndTime, releaseStartTime, results;
      extraLength = length > this.asdr.attack + this.asdr.decay ? length - this.asdr.attack - this.asdr.decay : 0;
      now = Audanism.Audio.audioContext.currentTime + this.waitTime;
      attackEndTime = now + this.asdr.attack;
      decayEndTime = attackEndTime + this.asdr.decay;
      releaseStartTime = length >= 0 ? decayEndTime + extraLength : 0;
      releaseEndTime = releaseStartTime + this.asdr.release;
      results = [];
      for (i = j = 0, ref = this.envelopes.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        env = this.envelopes[i];
        env.gain.cancelScheduledValues(now);
        env.gain.setValueAtTime(env.gain.value, now);
        env.gain.linearRampToValueAtTime(1, attackEndTime);
        env.gain.linearRampToValueAtTime(this.asdr.sustain, decayEndTime);
        if (extraLength > 0) {
          env.gain.linearRampToValueAtTime(this.asdr.sustain, releaseStartTime);
        }
        if (length >= 0) {
          results.push(env.gain.linearRampToValueAtTime(0, releaseEndTime));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Voice.prototype.noteOff = function() {
      var e, env, error, i, j, now, ref, releaseEndTime, results;
      now = Audanism.Audio.audioContext.currentTime;
      releaseEndTime = now + this.asdr.release;
      results = [];
      for (i = j = 0, ref = this.envelopes.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        env = this.envelopes[i];
        env.gain.cancelScheduledValues(now);
        env.gain.setValueAtTime(env.gain.value, now);
        env.gain.linearRampToValueAtTime(0, releaseEndTime);
        try {
          results.push(this.oscillators[i].stop(releaseEndTime + 0.01));
        } catch (error) {
          e = error;
        }
      }
      return results;
    };

    Voice.prototype.stop = function(wait) {
      var j, len, osc, ref, results;
      if (wait == null) {
        wait = 0;
      }
      ref = this.oscillators;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        osc = ref[j];
        results.push(osc.stop(wait));
      }
      return results;
    };


    /*
    	 * Creates and returns an fx chain
    	createFxChain: () ->
    
    		id = @fxChains.length
    		console.log('Voice#createFxChain()')
    		console.log('...id', id)
    
    		chain = new Audanism.Audio.FX.FXChain( @fxIn, @masterWet )
    
    		#@fxIn.connect( chain.in )
    		#chain.out.connect( @masterWet )
    
    		@fxChains[@fxChains.length] = chain
    		return chain
    
    
    	 * Adds an effect to the main signal chain
    	 * @masterWet -> @fx -> @panPostFx
    	addFx: (@fx) ->
    		id = @fxs.length
    
    		if id is 0
    			@masterWet.disconnect( 0 )
    			@masterWet.connect( @fx.in )
    		else
    			@fxs[id - 1].out.disconnect( 0 )
    			@fxs[id - 1].out.connect( @fx.in )
    		
    		@fx.out.connect( @panPostFx )
    		@fxs[id] = @fx
    
    	 * Pan pre fx
    	setPanPreFx: (pan) ->
    		@panPreFx.setPosition( pan, 0, 0 )
    
    
    	 * Pan post fx
    	setPanPostFx: (pan) ->
    		@panPostFx.setPosition( pan, 0, 0 )
    
    
    	 * Dry amount
    	setDryAmunt: (dryAmount) ->
    		@dry.gain.value = dryAmount
    
    
    	 * Wet (fx) amount
    	setMasterWetAmount: (wetAmount) ->
    		@masterWet.gain.value = wetAmount
     */

    Voice.prototype.setPan = function(pan) {
      return this.pan.setPosition(pan, 0, 0);
    };

    Voice.prototype.getRandomOscType = function() {
      var oscTypes;
      oscTypes = ['sine', 'sawtooth', 'square', 'triangle'];
      return oscTypes[randomInt(0, 3)];
    };

    return Voice;

  })();

  window.Audanism.Audio.Synthesizer.Voice = Voice;

}).call(this);
